import {MainController} from "../../../MainController";
import {checkFramebuffer} from "../../../../Util/FramebufferCheck";
import {FrameInfo, RenderQueueMaterialEntry, RenderQueueMeshEntry} from "../../RenderController";
import {DrawMesh} from "../../../../Render/DrawMesh";
import {DayLight} from "../../../../Render/Resource/Light/DayLight";
import {flatMat4} from "../../../../Geometry/Matrix/flatten";
import {getOrthographicMatrix} from "../../../../Geometry/Matrix/orthographic";
import {lookAtMatrix} from "../../../../Geometry/Matrix/lookAt";
import {Camera} from "../../../../Render/Camera/Camera";
import {addVec3} from "../../../../Geometry/Vector/add";
import {scaleVec3} from "../../../../Geometry/Vector/scale";
import {vec3} from "../../../../Geometry/Vector/vec";
import {crossProductVec3} from "../../../../Geometry/Vector/crossProduct";
import {RenderOptions} from "../../../../Scene/RenderOptions";

export abstract class GeometryPassShadowExtension {

    // Generated By Geometry Pass!
    static shadow_framebuffer: WebGLFramebuffer;

    static depth_texture: WebGLTexture;
    static shadow_texture: WebGLTexture;

    static set_up_size: number = 1920;

    static appSetup(): void {
       const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();
        /**
         * Position FRAMEBUFFER
         * RGB = XYZ from ScreenSpace pressed
         */

        ////////////////////////////////////////////
        // BIND FRAMEBUFFER
        ////////////////////////////////////////////
        GeometryPassShadowExtension.shadow_framebuffer = GL.createFramebuffer();

        GeometryPassShadowExtension.setupTextures(GL, GeometryPassShadowExtension.set_up_size);
        ////////////////////////////////////////////
        // SETUP DRAW BUFFER
        // CHECK STATUS
        // & UNBIND THE SHIT
        ////////////////////////////////////////////

        checkFramebuffer(GL, GeometryPassShadowExtension.shadow_framebuffer);

        // reset used bindings
        GL.bindRenderbuffer(GL.RENDERBUFFER, null);
        GL.bindTexture(GL.TEXTURE_2D, null);
        GL.bindFramebuffer(GL.FRAMEBUFFER, null);
    }
    
    static frameSetup(frame_info: FrameInfo, newRenderOptions: RenderOptions): void {
        const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();

        console.log(newRenderOptions.shadow_texture_precision)

        if(GeometryPassShadowExtension.set_up_size !== newRenderOptions.shadow_texture_precision) {
            GeometryPassShadowExtension.setupTextures(GL, newRenderOptions.shadow_texture_precision);
            GeometryPassShadowExtension.set_up_size = newRenderOptions.shadow_texture_precision;
        }

        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPassShadowExtension.shadow_framebuffer);
        GL.viewport(0, 0, GeometryPassShadowExtension.set_up_size, GeometryPassShadowExtension.set_up_size);
        GL.clearColor(0.0, 0.0, 0.0, 1.0);
        GL.enable(GL.DEPTH_TEST);
        GL.depthFunc(GL.LEQUAL);
        GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

        let daylight: DayLight;
        if(
            MainController.SceneController.getSceneAltBalance() > 0.5 &&
            MainController.SceneController.getSceneDayLightAlt() != null
        ) {
            daylight = MainController.SceneController.getSceneDayLightAlt();
        } else {
            daylight = MainController.SceneController.getSceneDayLight();
        }

        const cam: Camera = MainController.SceneController.getSceneCamera();
        GeometryPassShadowExtension.proj_matrix = flatMat4(getOrthographicMatrix(
            -(cam.getShadowFrustum()),
            (cam.getShadowFrustum()),
            -(cam.getShadowFrustum()),
            (cam.getShadowFrustum()),
            5.0,
            (cam.farPlane)
        ));
        GeometryPassShadowExtension.view_matrix = flatMat4(lookAtMatrix(
            addVec3(cam.target, scaleVec3(daylight.direction, -cam.getShadowFrustum())),
            cam.target,
            calculateUsefulUpVector(daylight.direction)
        ));
        MainController.ShaderController.useShadowShader();
        GeometryPassShadowExtension.bindDayLightMatrix(
            MainController.ShaderController.getShadowShader().uniform_locations.view_matrix,
            MainController.ShaderController.getShadowShader().uniform_locations.projection_matrix,
        );
        MainController.ShaderController.useDeferredLightningShader();
        GeometryPassShadowExtension.bindDayLightMatrix(
            MainController.ShaderController.getDeferredLightningShader().uniform_locations.daylight_view_matrix,
            MainController.ShaderController.getDeferredLightningShader().uniform_locations.daylight_projection_matrix,
        );
    }

    private static view_matrix: number[];
    private static proj_matrix: number[];

    static bindForDrawShadow(): void {
        const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();
        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPassShadowExtension.shadow_framebuffer);
        MainController.ShaderController.useShadowShader();
    }

    static bindDayLightMatrix(
        view_matrix_uniform: WebGLUniformLocation,
        projection_matrix_uniform: WebGLUniformLocation,
    ){
        const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();
        GL.uniformMatrix4fv(
            view_matrix_uniform,
            false,
            new Float32Array(GeometryPassShadowExtension.view_matrix)
        );
        GL.uniformMatrix4fv(
            projection_matrix_uniform,
            false,
            new Float32Array(GeometryPassShadowExtension.proj_matrix)
        );
    }

    static setupTextures(GL: WebGL2RenderingContext, size: number) {
        const INTERN_FORMAT = GL.RGBA32F;
        const FILTER = GL.NEAREST;
        const LEVEL = 1;

        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPassShadowExtension.shadow_framebuffer);
        GL.activeTexture(GL.TEXTURE0);

        ////////////////////////////////////////////
        // BIND DEPTH Texture
        ////////////////////////////////////////////
        if(GeometryPassShadowExtension.depth_texture !== undefined) {
            console.log('delete texture to recreate')
            GL.deleteTexture(GeometryPassShadowExtension.depth_texture)
        }
        GeometryPassShadowExtension.depth_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPassShadowExtension.depth_texture);
        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, 0);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            GL.DEPTH_COMPONENT32F,
            size,
            size
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.DEPTH_ATTACHMENT, GL.TEXTURE_2D, GeometryPassShadowExtension.depth_texture, 0);

        ////////////////////////////////////////////
        // CREATE POSITION TEXTURE
        ////////////////////////////////////////////
        if(GeometryPassShadowExtension.shadow_texture !== undefined) {
            GL.deleteTexture(GeometryPassShadowExtension.shadow_texture)
        }
        GeometryPassShadowExtension.shadow_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPassShadowExtension.shadow_texture);
        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, 0);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            INTERN_FORMAT,
            size,
            size
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, GeometryPassShadowExtension.shadow_texture, 0);
        GL.drawBuffers([GL.COLOR_ATTACHMENT0]);
    }
}

function calculateUsefulUpVector(direction: vec3): vec3 {
    return crossProductVec3(
        direction,
        {x: 0.0, y: 0.0, z: 1.0}
    );
}