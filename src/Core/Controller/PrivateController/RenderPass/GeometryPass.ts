import {MainController} from "../../MainController";
import {checkFramebuffer} from "../../../Util/FramebufferCheck";
import {FrameInfo, GraphicOptions, RenderQueueMaterialEntry, RenderQueueMeshEntry} from "../RenderController";
import {DrawMesh} from "../../../Render/DrawMesh";
import {mat4} from "../../../Geometry/Matrix/mat";
import {flatMat4} from "../../../Geometry/Matrix/flatten";

export abstract class GeometryPass {

    static model_mesh_buffer_prepared: boolean = false;
    static model_mesh_matrix_buffer: WebGLBuffer;
    
    // Generated By Geometry Pass!
    static position_framebuffer: WebGLFramebuffer;
    static position_depth_rbuffer: WebGLRenderbuffer;
    static position_texture: WebGLTexture;

    static albedo_framebuffer: WebGLFramebuffer;
    static albedo_depth_rbuffer: WebGLRenderbuffer;
    static albedo_texture: WebGLTexture;

    static specular_framebuffer: WebGLFramebuffer;
    static specular_depth_rbuffer: WebGLRenderbuffer;
    static specular_texture: WebGLTexture;

    static normal_framebuffer: WebGLFramebuffer;
    static normal_depth_rbuffer: WebGLRenderbuffer;
    static normal_texture: WebGLTexture;

    static material_framebuffer: WebGLFramebuffer;
    static material_depth_rbuffer: WebGLRenderbuffer;
    static material_texture: WebGLTexture;
    
    static appSetup(): void {
       const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();
        /**
         * Position FRAMEBUFFER
         * RGB = XYZ from ScreenSpace pressed
         */

        const SIZEX = 1920;
        const SIZEY = 1920;
        const INTERN_FORMAT = GL.RGBA16F;
        const INPT_FORMAT = GL.RGB;
        const TYPE = GL.FLOAT;
        const FILTER = GL.NEAREST;
        const LEVEL = 1;

        GeometryPass.position_framebuffer = GL.createFramebuffer();
        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.position_framebuffer);

        GL.activeTexture(GL.TEXTURE0);

        GeometryPass.position_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPass.position_texture);
        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, 0);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            INTERN_FORMAT,
            SIZEX,
            SIZEY
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, GeometryPass.position_texture, 0);

        GeometryPass.position_depth_rbuffer = GL.createRenderbuffer();
        GL.bindRenderbuffer(GL.RENDERBUFFER, GeometryPass.position_depth_rbuffer);
        GL.renderbufferStorage(GL.RENDERBUFFER, GL.DEPTH24_STENCIL8, SIZEX, SIZEX);
        GL.framebufferRenderbuffer(GL.FRAMEBUFFER, GL.DEPTH_STENCIL_ATTACHMENT, GL.RENDERBUFFER, GeometryPass.position_depth_rbuffer);

        checkFramebuffer(GL, GeometryPass.position_framebuffer);

        /**
         * ALBEDO FRAMEBUFFER
         * RGB = RGB Diffuse Values
         */
        GeometryPass.albedo_framebuffer = GL.createFramebuffer();
        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.albedo_framebuffer);
        GL.activeTexture(GL.TEXTURE0);

        GeometryPass.albedo_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPass.albedo_texture);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            INTERN_FORMAT,
            SIZEX,
            SIZEY
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, GeometryPass.albedo_texture, 0);

        GeometryPass.albedo_depth_rbuffer = GL.createRenderbuffer();
        GL.bindRenderbuffer(GL.RENDERBUFFER, GeometryPass.albedo_depth_rbuffer);
        GL.renderbufferStorage(GL.RENDERBUFFER, GL.DEPTH24_STENCIL8, SIZEX, SIZEX);
        GL.framebufferRenderbuffer(GL.FRAMEBUFFER, GL.DEPTH_STENCIL_ATTACHMENT, GL.RENDERBUFFER, GeometryPass.albedo_depth_rbuffer);

        checkFramebuffer(GL, GeometryPass.albedo_framebuffer);


        /**
         * SPECULAR FRAMEBUFFER
         * RGB = RGB Specular Values
         */
        GeometryPass.specular_framebuffer = GL.createFramebuffer();
        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.specular_framebuffer);
        GL.activeTexture(GL.TEXTURE0);

        GeometryPass.specular_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPass.specular_texture);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            INTERN_FORMAT,
            SIZEX,
            SIZEY
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, GeometryPass.specular_texture, 0);

        GeometryPass.specular_depth_rbuffer = GL.createRenderbuffer();
        GL.bindRenderbuffer(GL.RENDERBUFFER, GeometryPass.specular_depth_rbuffer);
        GL.renderbufferStorage(GL.RENDERBUFFER, GL.DEPTH24_STENCIL8, SIZEX, SIZEX);
        GL.framebufferRenderbuffer(GL.FRAMEBUFFER, GL.DEPTH_STENCIL_ATTACHMENT, GL.RENDERBUFFER, GeometryPass.specular_depth_rbuffer);

        checkFramebuffer(GL, GeometryPass.specular_framebuffer);

        /**
         * NORMAL FRAMEBUFFER
         * RGB = XYZ pressed Normal vectors
         */
        GeometryPass.normal_framebuffer = GL.createFramebuffer();
        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.normal_framebuffer);
        GL.activeTexture(GL.TEXTURE0);

        GeometryPass.normal_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPass.normal_texture);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            INTERN_FORMAT,
            SIZEX,
            SIZEY
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, GeometryPass.normal_texture, 0);

        GeometryPass.normal_depth_rbuffer = GL.createRenderbuffer();
        GL.bindRenderbuffer(GL.RENDERBUFFER, GeometryPass.normal_depth_rbuffer);
        GL.renderbufferStorage(GL.RENDERBUFFER, GL.DEPTH24_STENCIL8, SIZEX, SIZEX);
        GL.framebufferRenderbuffer(GL.FRAMEBUFFER, GL.DEPTH_STENCIL_ATTACHMENT, GL.RENDERBUFFER, GeometryPass.normal_depth_rbuffer);

        checkFramebuffer(GL, GeometryPass.normal_framebuffer);

        /**
         * Material FRAMEBUFFER
         * R = Shininess
         * G = Reflectiveness
         */
        GeometryPass.material_framebuffer = GL.createFramebuffer();
        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.material_framebuffer);
        GL.activeTexture(GL.TEXTURE0);

        GeometryPass.material_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPass.material_texture);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            INTERN_FORMAT,
            SIZEX,
            SIZEY
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, GeometryPass.material_texture, 0);

        GeometryPass.material_depth_rbuffer = GL.createRenderbuffer();
        GL.bindRenderbuffer(GL.RENDERBUFFER, GeometryPass.material_depth_rbuffer);
        GL.renderbufferStorage(GL.RENDERBUFFER, GL.DEPTH24_STENCIL8, SIZEX, SIZEX);
        GL.framebufferRenderbuffer(GL.FRAMEBUFFER, GL.DEPTH_STENCIL_ATTACHMENT, GL.RENDERBUFFER, GeometryPass.material_depth_rbuffer);

        checkFramebuffer(GL, GeometryPass.material_framebuffer);

        // reset used bindings
        GL.bindRenderbuffer(GL.RENDERBUFFER, null);
        GL.bindTexture(GL.TEXTURE_2D, null);
        GL.bindFramebuffer(GL.FRAMEBUFFER, null);
    }
    
    static frameSetup(frame_info: FrameInfo): void {
        // const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();
        
    }
    
    static runPass(render_queue: RenderQueueMeshEntry[], frame_info: FrameInfo): void {
        const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();

        MainController.ShaderController.useGeometryShader();

        GL.viewport(0, 0, 1920, 1920);
        GL.enable(GL.DEPTH_TEST);
        GL.depthFunc(GL.LESS);

        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.position_framebuffer);
        GL.clearColor(0.1, 0, 0, 0.0);
        GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.albedo_framebuffer);
        GL.clearColor(0, 0.1, 0, 0.0);
        GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.specular_framebuffer);
        GL.clearColor(0, 0, 0.1, 0.0);
        GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.normal_framebuffer);
        GL.clearColor(0.1, 0.1, 0, 0.0);
        GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.material_framebuffer);
        GL.clearColor(0.0, 0.1, 0.1, 0.0);
        GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

        // Set Data for Camera
        MainController.SceneController.getSceneCamera().bingForGeometryShader(GL);

        render_queue.forEach(
            (render_queue_mesh_entry: RenderQueueMeshEntry) => {
                // there has to be an entry so select from the first
                const mesh_to_use = render_queue_mesh_entry.render_queue_material_entries[0].draw_meshes[0].related_mesh;
                // activate mesh
                mesh_to_use.use(GL);

                render_queue_mesh_entry.render_queue_material_entries.forEach(
                    (render_queue_entry: RenderQueueMaterialEntry) => {

                        // first, bind mesh transformation matrix
                        GeometryPass.geometryPassPrepareUniformMeshData(render_queue_entry.draw_meshes);

                        // second activate material
                        const material_to_use = render_queue_entry.draw_meshes[0].related_material;
                        material_to_use.use(GL, MainController.ShaderController.getGeometryShader());


                        // Buffer Albedo Task Number
                        GeometryPass.bufferSubDataTask(GL, 1);
                        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.albedo_framebuffer);
                        GeometryPass.geometryPassDrawMeshTasks(render_queue_entry.draw_meshes);


                        // Buffer Albedo Task Number
                        GeometryPass.bufferSubDataTask(GL, 2);
                        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.specular_framebuffer);
                        GeometryPass.geometryPassDrawMeshTasks(render_queue_entry.draw_meshes);


                        // Buffer Albedo Task Number
                        GeometryPass.bufferSubDataTask(GL, 3);
                        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.normal_framebuffer);
                        GeometryPass.geometryPassDrawMeshTasks(render_queue_entry.draw_meshes);

                        // Buffer Albedo Task Number
                        GeometryPass.bufferSubDataTask(GL, 4);
                        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.position_framebuffer);
                        GeometryPass.geometryPassDrawMeshTasks(render_queue_entry.draw_meshes);

                        // Buffer Albedo Task Number
                        GeometryPass.bufferSubDataTask(GL, 5);
                        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.material_framebuffer);
                        GeometryPass.geometryPassDrawMeshTasks(render_queue_entry.draw_meshes);

                    }
                );
            }
        )
        GL.bindFramebuffer(GL.FRAMEBUFFER, null);
        GL.viewport(0, 0, frame_info.width, frame_info.height);
    }

    private static bufferSubDataTask(GL: WebGL2RenderingContext, task: number) {
        GL.bufferSubData(GL.UNIFORM_BUFFER, 11 * 4, new Float32Array([task]));
    }

    private static geometryPassPrepareUniformMeshData(taskList: DrawMesh[]) {
        const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();

        if (!GeometryPass.model_mesh_buffer_prepared) {
            GeometryPass.setMeshAndModelAttributePointer(GL);
        }

        let bufferData: number[] = [];
        // Collect Data to buffer
        taskList.forEach(
            (task: DrawMesh, index: number, list: DrawMesh[]) => {
                // Prepare Current rendering
                for(let i = 0; i < 16; i++) {
                    bufferData.push(task.related_mesh.transformation.getMatrix()[i]);
                }
                for(let i = 0; i < 16; i++) {
                    bufferData.push(task.related_model.transformation.getMatrix()[i]);
                }
            }
        );

        // Buffer Data
        GL.bindBuffer(GL.ARRAY_BUFFER, GeometryPass.model_mesh_matrix_buffer);
        GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(bufferData), GL.DYNAMIC_DRAW);
    }

    private static geometryPassDrawMeshTasks(taskList: DrawMesh[]) {
        const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();
        GL.drawArraysInstanced(GL.TRIANGLES, 0, taskList[0].related_mesh.draw_count, taskList.length);
    }

    private static createMeshModelBuffer() {
        // do render task
        const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();
        GeometryPass.model_mesh_matrix_buffer = GL.createBuffer();
        GL.bindBuffer(GL.ARRAY_BUFFER, GeometryPass.model_mesh_matrix_buffer);
        GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(32), GL.DYNAMIC_DRAW);
        GL.bindBuffer(GL.ARRAY_BUFFER, null);
        GeometryPass.model_mesh_buffer_prepared = true;

    }

    static setMeshAndModelAttributePointer(GL: WebGL2RenderingContext) {

        if(!GeometryPass.model_mesh_buffer_prepared) {
            GeometryPass.createMeshModelBuffer();
        }

        // Prepare Geometry Bindings
        const model_matrix_location: number = MainController.ShaderController.getGeometryShader().attribute_pointer.model_matrix;
        const mesh_matrix_location: number = MainController.ShaderController.getGeometryShader().attribute_pointer.mesh_matrix;

        GL.bindBuffer(GL.ARRAY_BUFFER, GeometryPass.model_mesh_matrix_buffer);
        // Define Attribute Matrix Pointer
        GL.enableVertexAttribArray(model_matrix_location);
        GL.vertexAttribPointer(model_matrix_location, 4, GL.FLOAT, false, 32 * 4, 0);
        GL.vertexAttribDivisor(model_matrix_location, 1);

        GL.enableVertexAttribArray(model_matrix_location + 1);
        GL.vertexAttribPointer(model_matrix_location + 1, 4, GL.FLOAT, false, 32 * 4, 4 * 4);
        GL.vertexAttribDivisor(model_matrix_location + 1, 1);

        GL.enableVertexAttribArray(model_matrix_location + 2);
        GL.vertexAttribPointer(model_matrix_location + 2, 4, GL.FLOAT, false, 32 * 4, 8 * 4);
        GL.vertexAttribDivisor(model_matrix_location + 2, 1);

        GL.enableVertexAttribArray(model_matrix_location + 3);
        GL.vertexAttribPointer(model_matrix_location + 3, 4, GL.FLOAT, false, 32 * 4, 12 * 4);
        GL.vertexAttribDivisor(model_matrix_location + 3, 1);

        GL.enableVertexAttribArray(mesh_matrix_location);
        GL.vertexAttribPointer(mesh_matrix_location, 4, GL.FLOAT, false, 32 * 4, 16 * 4);
        GL.vertexAttribDivisor(mesh_matrix_location, 1);

        GL.enableVertexAttribArray(mesh_matrix_location + 1);
        GL.vertexAttribPointer(mesh_matrix_location + 1, 4, GL.FLOAT, false, 32 * 4, 20 * 4);
        GL.vertexAttribDivisor(mesh_matrix_location + 1, 1);

        GL.enableVertexAttribArray(mesh_matrix_location + 2);
        GL.vertexAttribPointer(mesh_matrix_location + 2, 4, GL.FLOAT, false, 32 * 4, 24 * 4);
        GL.vertexAttribDivisor(mesh_matrix_location + 2, 1);

        GL.enableVertexAttribArray(mesh_matrix_location + 3);
        GL.vertexAttribPointer(mesh_matrix_location + 3, 4, GL.FLOAT, false, 32 * 4, 28 * 4);
        GL.vertexAttribDivisor(mesh_matrix_location + 3, 1);

        GL.bindBuffer(GL.ARRAY_BUFFER, null);
    }
}