import {MainController} from "../../MainController";
import {checkFramebuffer} from "../../../Util/FramebufferCheck";
import {FrameInfo, RenderQueueMaterialEntry, RenderQueueMeshEntry} from "../RenderController";
import {DrawMesh} from "../../../Render/DrawMesh";
import {GeometryPassShadowExtension} from "./GeometryPassShadowExtension";

export abstract class GeometryPass {

    static model_mesh_buffer_prepared: boolean = false;
    static model_mesh_matrix_buffer: WebGLBuffer;
    
    // Generated By Geometry Pass!
    static geometry_framebuffer: WebGLFramebuffer;
    static geometry_depth_buffer: WebGLRenderbuffer;

    static position_texture: WebGLTexture;
    static albedo_texture: WebGLTexture;
    static specular_texture: WebGLTexture;
    static normal_texture: WebGLTexture;
    static material_texture: WebGLTexture;
    static depth_texture: WebGLTexture;
    
    static appSetup(): void {
       const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();
        /**
         * Position FRAMEBUFFER
         * RGB = XYZ from ScreenSpace pressed
         */

        const SIZEX = 1920;
        const SIZEY = 1920;
        const INTERN_FORMAT = GL.RGBA32F;
        const FILTER = GL.NEAREST;
        const LEVEL = 1;

        ////////////////////////////////////////////
        // BIND FRAMEBUFFER
        ////////////////////////////////////////////
        GeometryPass.geometry_framebuffer = GL.createFramebuffer();
        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.geometry_framebuffer);
        GL.activeTexture(GL.TEXTURE0);

        ////////////////////////////////////////////
        // BIND DEPTH BUFFER
        ////////////////////////////////////////////
        /*
        GeometryPass.geometry_depth_buffer = GL.createRenderbuffer();
        GL.bindRenderbuffer(GL.RENDERBUFFER, GeometryPass.geometry_depth_buffer);
        GL.renderbufferStorage(GL.RENDERBUFFER, GL.DEPTH24_STENCIL8, SIZEX, SIZEX);
        GL.framebufferRenderbuffer(GL.FRAMEBUFFER, GL.DEPTH_STENCIL_ATTACHMENT, GL.RENDERBUFFER, GeometryPass.geometry_depth_buffer);
        */

        ////////////////////////////////////////////
        // BIND DEPTH Texture
        ////////////////////////////////////////////
        GeometryPass.depth_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPass.depth_texture);
        // GL.texImage2D(GL.TEXTURE_2D, 0, GL.DEPTH_COMPONENT32F, SIZEX, SIZEY, 0, GL.DEPTH_COMPONENT, GL.FLOAT, null);
        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, 0);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            GL.DEPTH_COMPONENT32F,
            SIZEX,
            SIZEY
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.DEPTH_ATTACHMENT, GL.TEXTURE_2D, GeometryPass.depth_texture, 0);

        ////////////////////////////////////////////
        // CREATE POSITION TEXTURE
        ////////////////////////////////////////////
        GeometryPass.position_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPass.position_texture);
        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, 0);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            INTERN_FORMAT,
            SIZEX,
            SIZEY
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, GeometryPass.position_texture, 0);


        ////////////////////////////////////////////
        // CREATE POSITION TEXTURE
        ////////////////////////////////////////////
        GeometryPass.normal_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPass.normal_texture);
        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, 0);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            INTERN_FORMAT,
            SIZEX,
            SIZEY
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT1, GL.TEXTURE_2D, GeometryPass.normal_texture, 0);


        ////////////////////////////////////////////
        // CREATE ALBEDO TEXTURE
        ////////////////////////////////////////////
        GeometryPass.albedo_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPass.albedo_texture);
        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, 0);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            INTERN_FORMAT,
            SIZEX,
            SIZEY
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT2, GL.TEXTURE_2D, GeometryPass.albedo_texture, 0);


        ////////////////////////////////////////////
        // CREATE SPECULAR TEXTURE
        ////////////////////////////////////////////
        GeometryPass.specular_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPass.specular_texture);
        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, 0);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            INTERN_FORMAT,
            SIZEX,
            SIZEY
        );
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT3, GL.TEXTURE_2D, GeometryPass.specular_texture, 0);


        ////////////////////////////////////////////
        // CREATE MATERIAL TEXTURE
        ////////////////////////////////////////////
        GeometryPass.material_texture = GL.createTexture();
        GL.bindTexture(GL.TEXTURE_2D, GeometryPass.material_texture);
        //GL.texImage2D(GL.TEXTURE_2D, 0, INTERN_FORMAT, SIZEX, SIZEY, 0, GL.RGB32F, GL.FLOAT, null);

        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, 0);
        GL.texStorage2D(
            GL.TEXTURE_2D,
            LEVEL,
            INTERN_FORMAT,
            SIZEX,
            SIZEY
        );

        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, FILTER);
        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, FILTER);
        GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT4, GL.TEXTURE_2D, GeometryPass.material_texture, 0);


        ////////////////////////////////////////////
        // SETUP DRAW BUFFER
        // CHECK STATUS
        // & UNBIND THE SHIT
        ////////////////////////////////////////////
        GL.drawBuffers([
            GL.COLOR_ATTACHMENT0,
            GL.COLOR_ATTACHMENT1,
            GL.COLOR_ATTACHMENT2,
            GL.COLOR_ATTACHMENT3,
            GL.COLOR_ATTACHMENT4
        ]);

        checkFramebuffer(GL, GeometryPass.geometry_framebuffer);

        // reset used bindings
        GL.bindRenderbuffer(GL.RENDERBUFFER, null);
        GL.bindTexture(GL.TEXTURE_2D, null);
        GL.bindFramebuffer(GL.FRAMEBUFFER, null);

        GeometryPassShadowExtension.appSetup();
    }
    
    static frameSetup(frame_info: FrameInfo): void {
        // const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();
        GeometryPassShadowExtension.frameSetup(frame_info);
    }
    
    static runPass(render_queue: RenderQueueMeshEntry[], frame_info: FrameInfo): void {
        const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();

        MainController.ShaderController.useGeometryShader();

        GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.geometry_framebuffer);
        GL.clearColor(0.0, 0.0, 0.0, 1.0);
        GL.viewport(0, 0, 1920, 1920);
        GL.enable(GL.DEPTH_TEST);
        GL.depthFunc(GL.LEQUAL);
        // GL.enable(GL.CULL_FACE);
        // GL.cullFace(GL.BACK);

        GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);

        // Set Data for Camera
        MainController.SceneController.getSceneCamera().bingForGeometryShader(GL);


        render_queue.forEach(
            (render_queue_mesh_entry: RenderQueueMeshEntry) => {
                // there has to be an entry so select from the first
                const mesh_to_use = render_queue_mesh_entry.render_queue_material_entries[0].draw_meshes[0].related_mesh;
                // activate mesh
                mesh_to_use.use(GL);

                render_queue_mesh_entry.render_queue_material_entries.forEach(
                    (render_queue_entry: RenderQueueMaterialEntry) => {

                        // first, bind mesh transformation matrix
                        GeometryPass.geometryPassPrepareUniformMeshData(render_queue_entry.draw_meshes);

                        // second activate material

                        const material_to_use = render_queue_entry.draw_meshes[0].related_material;
                        material_to_use.use(GL, MainController.ShaderController.getGeometryShader());

                        GeometryPass.geometryPassDrawMeshTasks(render_queue_entry.draw_meshes);

                        // SHADOW PASS
                        if(true) {
                            GeometryPassShadowExtension.bindForDrawShadow();
                            GeometryPass.geometryPassDrawMeshTasks(render_queue_entry.draw_meshes);
                            // bind back normal geometry shader framebuffer
                            GL.bindFramebuffer(GL.FRAMEBUFFER, GeometryPass.geometry_framebuffer);
                            MainController.ShaderController.useGeometryShader();
                        }
                    }
                );
            }
        );
        GL.bindFramebuffer(GL.FRAMEBUFFER, null);
        GL.viewport(0, 0, frame_info.width, frame_info.height);
    }

    private static geometryPassPrepareUniformMeshData(taskList: DrawMesh[]) {
        const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();

        if (!GeometryPass.model_mesh_buffer_prepared) {
            GeometryPass.setMeshAndModelAttributePointer(GL);
        }

        let bufferData: number[] = [];
        // Collect Data to buffer
        taskList.forEach(
            (task: DrawMesh, index: number, list: DrawMesh[]) => {
                // Prepare Current rendering
                for(let i = 0; i < 16; i++) {
                    bufferData.push(task.related_mesh.transformation.getMatrix()[i]);
                }
                for(let i = 0; i < 16; i++) {
                    bufferData.push(task.related_model.transformation.getMatrix()[i]);
                }
            }
        );

        // Buffer Data
        GL.bindBuffer(GL.ARRAY_BUFFER, GeometryPass.model_mesh_matrix_buffer);
        GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(bufferData), GL.DYNAMIC_DRAW);
    }

    private static geometryPassDrawMeshTasks(taskList: DrawMesh[]) {
        const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();
        GL.drawArraysInstanced(GL.TRIANGLES, 0, taskList[0].related_mesh.draw_count, taskList.length);
    }

    private static createMeshModelBuffer() {
        // do render task
        const GL: WebGL2RenderingContext = MainController.CanvasController.getGL();
        GeometryPass.model_mesh_matrix_buffer = GL.createBuffer();
        GL.bindBuffer(GL.ARRAY_BUFFER, GeometryPass.model_mesh_matrix_buffer);
        GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(32), GL.DYNAMIC_DRAW);
        GL.bindBuffer(GL.ARRAY_BUFFER, null);
        GeometryPass.model_mesh_buffer_prepared = true;

    }

    static setMeshAndModelAttributePointer(GL: WebGL2RenderingContext) {

        if(!GeometryPass.model_mesh_buffer_prepared) {
            GeometryPass.createMeshModelBuffer();
        }

        // Prepare Geometry Bindings
        const geom_model_matrix_location: number = MainController.ShaderController.getGeometryShader().attribute_pointer.model_matrix;
        const geom_mesh_matrix_location: number = MainController.ShaderController.getGeometryShader().attribute_pointer.mesh_matrix;

        GL.bindBuffer(GL.ARRAY_BUFFER, GeometryPass.model_mesh_matrix_buffer);
        MainController.ShaderController.useGeometryShader();
        // Define Attribute Matrix Pointer
        GL.enableVertexAttribArray(geom_model_matrix_location);
        GL.vertexAttribPointer(geom_model_matrix_location, 4, GL.FLOAT, false, 32 * 4, 0);
        GL.vertexAttribDivisor(geom_model_matrix_location, 1);

        GL.enableVertexAttribArray(geom_model_matrix_location + 1);
        GL.vertexAttribPointer(geom_model_matrix_location + 1, 4, GL.FLOAT, false, 32 * 4, 4 * 4);
        GL.vertexAttribDivisor(geom_model_matrix_location + 1, 1);

        GL.enableVertexAttribArray(geom_model_matrix_location + 2);
        GL.vertexAttribPointer(geom_model_matrix_location + 2, 4, GL.FLOAT, false, 32 * 4, 8 * 4);
        GL.vertexAttribDivisor(geom_model_matrix_location + 2, 1);

        GL.enableVertexAttribArray(geom_model_matrix_location + 3);
        GL.vertexAttribPointer(geom_model_matrix_location + 3, 4, GL.FLOAT, false, 32 * 4, 12 * 4);
        GL.vertexAttribDivisor(geom_model_matrix_location + 3, 1);

        GL.enableVertexAttribArray(geom_mesh_matrix_location);
        GL.vertexAttribPointer(geom_mesh_matrix_location, 4, GL.FLOAT, false, 32 * 4, 16 * 4);
        GL.vertexAttribDivisor(geom_mesh_matrix_location, 1);

        GL.enableVertexAttribArray(geom_mesh_matrix_location + 1);
        GL.vertexAttribPointer(geom_mesh_matrix_location + 1, 4, GL.FLOAT, false, 32 * 4, 20 * 4);
        GL.vertexAttribDivisor(geom_mesh_matrix_location + 1, 1);

        GL.enableVertexAttribArray(geom_mesh_matrix_location + 2);
        GL.vertexAttribPointer(geom_mesh_matrix_location + 2, 4, GL.FLOAT, false, 32 * 4, 24 * 4);
        GL.vertexAttribDivisor(geom_mesh_matrix_location + 2, 1);

        GL.enableVertexAttribArray(geom_mesh_matrix_location + 3);
        GL.vertexAttribPointer(geom_mesh_matrix_location + 3, 4, GL.FLOAT, false, 32 * 4, 28 * 4);
        GL.vertexAttribDivisor(geom_mesh_matrix_location + 3, 1);

        // Prepare Geometry Bindings
        const shadow_model_matrix_location: number = MainController.ShaderController.getShadowShader().attribute_pointer.model_matrix;
        const shadow_mesh_matrix_location: number = MainController.ShaderController.getShadowShader().attribute_pointer.mesh_matrix;
        MainController.ShaderController.useShadowShader();

        // Define Attribute Matrix Pointer
        GL.enableVertexAttribArray(shadow_model_matrix_location);
        GL.vertexAttribPointer(shadow_model_matrix_location, 4, GL.FLOAT, false, 32 * 4, 0);
        GL.vertexAttribDivisor(shadow_model_matrix_location, 1);

        GL.enableVertexAttribArray(shadow_model_matrix_location + 1);
        GL.vertexAttribPointer(shadow_model_matrix_location + 1, 4, GL.FLOAT, false, 32 * 4, 4 * 4);
        GL.vertexAttribDivisor(shadow_model_matrix_location + 1, 1);

        GL.enableVertexAttribArray(shadow_model_matrix_location + 2);
        GL.vertexAttribPointer(shadow_model_matrix_location + 2, 4, GL.FLOAT, false, 32 * 4, 8 * 4);
        GL.vertexAttribDivisor(shadow_model_matrix_location + 2, 1);

        GL.enableVertexAttribArray(shadow_model_matrix_location + 3);
        GL.vertexAttribPointer(shadow_model_matrix_location + 3, 4, GL.FLOAT, false, 32 * 4, 12 * 4);
        GL.vertexAttribDivisor(shadow_model_matrix_location + 3, 1);

        GL.enableVertexAttribArray(shadow_mesh_matrix_location);
        GL.vertexAttribPointer(shadow_mesh_matrix_location, 4, GL.FLOAT, false, 32 * 4, 16 * 4);
        GL.vertexAttribDivisor(shadow_mesh_matrix_location, 1);

        GL.enableVertexAttribArray(shadow_mesh_matrix_location + 1);
        GL.vertexAttribPointer(shadow_mesh_matrix_location + 1, 4, GL.FLOAT, false, 32 * 4, 20 * 4);
        GL.vertexAttribDivisor(shadow_mesh_matrix_location + 1, 1);

        GL.enableVertexAttribArray(shadow_mesh_matrix_location + 2);
        GL.vertexAttribPointer(shadow_mesh_matrix_location + 2, 4, GL.FLOAT, false, 32 * 4, 24 * 4);
        GL.vertexAttribDivisor(shadow_mesh_matrix_location + 2, 1);

        GL.enableVertexAttribArray(shadow_mesh_matrix_location + 3);
        GL.vertexAttribPointer(shadow_mesh_matrix_location + 3, 4, GL.FLOAT, false, 32 * 4, 28 * 4);
        GL.vertexAttribDivisor(shadow_mesh_matrix_location + 3, 1);
        MainController.ShaderController.useGeometryShader();


        GL.bindBuffer(GL.ARRAY_BUFFER, null);
    }
}